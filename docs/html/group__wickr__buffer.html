<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wickr-crypto-c: wickr_buffer_t</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">wickr-crypto-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">wickr_buffer_t</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwickr__buffer.html">wickr_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an array of bytes and the length of the allocation associated with those bytes.  <a href="structwickr__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0cf6db371b58617c9311f2a357d98164"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#ga0cf6db371b58617c9311f2a357d98164">BUFFER_ARRAY_LEN</a>(x)&#160;&#160;&#160;(sizeof(x) / sizeof(<a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *))</td></tr>
<tr class="memdesc:ga0cf6db371b58617c9311f2a357d98164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of elements in an array of buffers (wickr_buffer_t **).  <a href="group__wickr__buffer.html#ga0cf6db371b58617c9311f2a357d98164">More...</a><br /></td></tr>
<tr class="separator:ga0cf6db371b58617c9311f2a357d98164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga305edd191e38eb040710b631c1e4f05f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#ga305edd191e38eb040710b631c1e4f05f">wickr_buffer_create_empty</a> (size_t len)</td></tr>
<tr class="memdesc:ga305edd191e38eb040710b631c1e4f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty buffer of size length.  <a href="group__wickr__buffer.html#ga305edd191e38eb040710b631c1e4f05f">More...</a><br /></td></tr>
<tr class="separator:ga305edd191e38eb040710b631c1e4f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0ae148a2f75e50eb3d36a4bef509d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#gaba0ae148a2f75e50eb3d36a4bef509d2">wickr_buffer_create_empty_zero</a> (size_t len)</td></tr>
<tr class="memdesc:gaba0ae148a2f75e50eb3d36a4bef509d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an zeroed empty buffer of size length.  <a href="group__wickr__buffer.html#gaba0ae148a2f75e50eb3d36a4bef509d2">More...</a><br /></td></tr>
<tr class="separator:gaba0ae148a2f75e50eb3d36a4bef509d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3ad1220af28781bf678cab20e2f1c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#gacc3ad1220af28781bf678cab20e2f1c8">wickr_buffer_create</a> (const uint8_t *bytes, size_t len)</td></tr>
<tr class="memdesc:gacc3ad1220af28781bf678cab20e2f1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer by copying an existing pointer to bytes of a specified length len.  <a href="group__wickr__buffer.html#gacc3ad1220af28781bf678cab20e2f1c8">More...</a><br /></td></tr>
<tr class="separator:gacc3ad1220af28781bf678cab20e2f1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada179dda91e748d7bdf6028d3d4c4bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#gada179dda91e748d7bdf6028d3d4c4bcd">wickr_buffer_copy</a> (const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *source)</td></tr>
<tr class="memdesc:gada179dda91e748d7bdf6028d3d4c4bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a buffer.  <a href="group__wickr__buffer.html#gada179dda91e748d7bdf6028d3d4c4bcd">More...</a><br /></td></tr>
<tr class="separator:gada179dda91e748d7bdf6028d3d4c4bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb6345c35ac2f6330ea0a685ce3fc53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#gaceb6345c35ac2f6330ea0a685ce3fc53">wickr_buffer_copy_section</a> (const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *source, size_t start, size_t len)</td></tr>
<tr class="memdesc:gaceb6345c35ac2f6330ea0a685ce3fc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer using a subsection of another buffer.  <a href="group__wickr__buffer.html#gaceb6345c35ac2f6330ea0a685ce3fc53">More...</a><br /></td></tr>
<tr class="separator:gaceb6345c35ac2f6330ea0a685ce3fc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f817bf762e4ee401b31685197620be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#ga67f817bf762e4ee401b31685197620be">wickr_buffer_modify_section</a> (const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *buffer, const uint8_t *bytes, size_t start, size_t len)</td></tr>
<tr class="memdesc:ga67f817bf762e4ee401b31685197620be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a subsection of a buffer.  <a href="group__wickr__buffer.html#ga67f817bf762e4ee401b31685197620be">More...</a><br /></td></tr>
<tr class="separator:ga67f817bf762e4ee401b31685197620be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7721c1033a1fc378a0a11613f3cfb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#gad7721c1033a1fc378a0a11613f3cfb26">wickr_buffer_concat</a> (const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *buffer1, const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *buffer2)</td></tr>
<tr class="memdesc:gad7721c1033a1fc378a0a11613f3cfb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two buffers into one new buffer.  <a href="group__wickr__buffer.html#gad7721c1033a1fc378a0a11613f3cfb26">More...</a><br /></td></tr>
<tr class="separator:gad7721c1033a1fc378a0a11613f3cfb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa7ea751a65310184d6c0ea9627dca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#ga3aa7ea751a65310184d6c0ea9627dca8">wickr_buffer_concat_multi</a> (<a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> **buffers, uint8_t n_buffers)</td></tr>
<tr class="memdesc:ga3aa7ea751a65310184d6c0ea9627dca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate n buffers.  <a href="group__wickr__buffer.html#ga3aa7ea751a65310184d6c0ea9627dca8">More...</a><br /></td></tr>
<tr class="separator:ga3aa7ea751a65310184d6c0ea9627dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ec58848ab0b07d164c6f7d73200c24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#ga51ec58848ab0b07d164c6f7d73200c24">wickr_buffer_is_equal</a> (const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *b1, const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *b2, wickr_buffer_compare_func compare_func)</td></tr>
<tr class="memdesc:ga51ec58848ab0b07d164c6f7d73200c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare buffers for equality.  <a href="group__wickr__buffer.html#ga51ec58848ab0b07d164c6f7d73200c24">More...</a><br /></td></tr>
<tr class="separator:ga51ec58848ab0b07d164c6f7d73200c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec1198db0739f3034ddd3969c64257f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#ga7ec1198db0739f3034ddd3969c64257f">wickr_buffer_destroy</a> (<a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> **buffer)</td></tr>
<tr class="memdesc:ga7ec1198db0739f3034ddd3969c64257f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a buffer.  <a href="group__wickr__buffer.html#ga7ec1198db0739f3034ddd3969c64257f">More...</a><br /></td></tr>
<tr class="separator:ga7ec1198db0739f3034ddd3969c64257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ff6486debbfd676b7675f6f899fc40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__wickr__buffer.html#gaf0ff6486debbfd676b7675f6f899fc40">wickr_buffer_destroy_zero</a> (<a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> **buffer)</td></tr>
<tr class="memdesc:gaf0ff6486debbfd676b7675f6f899fc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-then-deallocate a buffer.  <a href="group__wickr__buffer.html#gaf0ff6486debbfd676b7675f6f899fc40">More...</a><br /></td></tr>
<tr class="separator:gaf0ff6486debbfd676b7675f6f899fc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0cf6db371b58617c9311f2a357d98164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf6db371b58617c9311f2a357d98164">&#9670;&nbsp;</a></span>BUFFER_ARRAY_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFER_ARRAY_LEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(x) / sizeof(<a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the number of elements in an array of buffers (wickr_buffer_t **). </p>
<p>NOTE: This function will only work on stack allocated arrays. It is meant only to be used in cases where the length of the array of buffers is determined at compile time, on the stack.</p>
<p>EXAMPLE: wickr_buffer_t *elements[] = { b1, b2 b3 }.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>pointer to an array of wickr_buffer_t elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the array pointed to by x </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad7721c1033a1fc378a0a11613f3cfb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7721c1033a1fc378a0a11613f3cfb26">&#9670;&nbsp;</a></span>wickr_buffer_concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two buffers into one new buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer1</td><td>first source buffer </td></tr>
    <tr><td class="paramname">buffer2</td><td>second source buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer containing copied bytes from 'buffer1' followed by copied bytes from 'buffer2'. NULL if the length of 'buffer1' combind with the length of 'buffer2' exceeds MAX_BUFFER_SIZE </dd></dl>

</div>
</div>
<a id="ga3aa7ea751a65310184d6c0ea9627dca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aa7ea751a65310184d6c0ea9627dca8">&#9670;&nbsp;</a></span>wickr_buffer_concat_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_concat_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>n_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate n buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>a pointer to an array of buffers of n length </td></tr>
    <tr><td class="paramname">n_buffers</td><td>the number of buffers in the array pointed to by buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer containing copied bytes from each buffer in 'buffers'. NULL if 'buffers' contains a NULL or the total number of bytes held by 'buffers' exceeds MAX_BUFFER_SIZE </dd></dl>

</div>
</div>
<a id="gada179dda91e748d7bdf6028d3d4c4bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada179dda91e748d7bdf6028d3d4c4bcd">&#9670;&nbsp;</a></span>wickr_buffer_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the buffer to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer containing a copy of the bytes held in source. The new buffer maintains ownership of the copied bytes </dd></dl>

</div>
</div>
<a id="gaceb6345c35ac2f6330ea0a685ce3fc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb6345c35ac2f6330ea0a685ce3fc53">&#9670;&nbsp;</a></span>wickr_buffer_copy_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_copy_section </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a buffer using a subsection of another buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the buffer to copy bytes out of </td></tr>
    <tr><td class="paramname">start</td><td>the offset to start the copy process. Must be within the bounds 0 to source-&gt;length - 1 </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to copy out of 'source'. start + len must be less than source-&gt;length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer containing the bytes within the range of start to start + len. NULL if start + len exceeds the length of source, or if start is out of bounds </dd></dl>

</div>
</div>
<a id="gacc3ad1220af28781bf678cab20e2f1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc3ad1220af28781bf678cab20e2f1c8">&#9670;&nbsp;</a></span>wickr_buffer_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_create </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer by copying an existing pointer to bytes of a specified length len. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>a valid pointer to bytes of at least size len </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes the buffer should hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer holding len bytes copied from bytes. </dd></dl>

</div>
</div>
<a id="ga305edd191e38eb040710b631c1e4f05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305edd191e38eb040710b631c1e4f05f">&#9670;&nbsp;</a></span>wickr_buffer_create_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_create_empty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty buffer of size length. </p>
<p>The bytes in the output are uninitialized</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the number of bytes the buffer should hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer holding len bytes, or NULL if allocation fails or len is 0. </dd></dl>

</div>
</div>
<a id="gaba0ae148a2f75e50eb3d36a4bef509d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba0ae148a2f75e50eb3d36a4bef509d2">&#9670;&nbsp;</a></span>wickr_buffer_create_empty_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a>* wickr_buffer_create_empty_zero </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an zeroed empty buffer of size length. </p>
<p>The bytes in the output are initialized to 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the number of bytes the buffer should hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated buffer holding len bytes, or NULL if allocation fails or len is 0. </dd></dl>

</div>
</div>
<a id="ga7ec1198db0739f3034ddd3969c64257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec1198db0739f3034ddd3969c64257f">&#9670;&nbsp;</a></span>wickr_buffer_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_buffer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> **&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a buffer. </p>
<p>NOTE: This function does not modify the contents of buffer and simply calls free to deallocate the memory held. To zero out memory before deallocation use 'wickr_buffer_destroy_zero'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0ff6486debbfd676b7675f6f899fc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ff6486debbfd676b7675f6f899fc40">&#9670;&nbsp;</a></span>wickr_buffer_destroy_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wickr_buffer_destroy_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> **&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero-then-deallocate a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer to zero out and then destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51ec58848ab0b07d164c6f7d73200c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ec58848ab0b07d164c6f7d73200c24">&#9670;&nbsp;</a></span>wickr_buffer_is_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wickr_buffer_is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wickr_buffer_compare_func&#160;</td>
          <td class="paramname"><em>compare_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare buffers for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>buffer to compare to b2 </td></tr>
    <tr><td class="paramname">b2</td><td>buffer to compare to b1 </td></tr>
    <tr><td class="paramname">compare_func</td><td>the function that will be used to compare the buffers. Passing NULL will result in memcmp being used. Function takes input as const volatile to support constant time memory comparison implemented by many crypto libraries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the buffers are equal in length and in content </dd></dl>

</div>
</div>
<a id="ga67f817bf762e4ee401b31685197620be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67f817bf762e4ee401b31685197620be">&#9670;&nbsp;</a></span>wickr_buffer_modify_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wickr_buffer_modify_section </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structwickr__buffer.html">wickr_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a subsection of a buffer. </p>
<p>NOTE: Buffers will not grow to accomidate extra bytes. The size of a buffer is currently fixed and cannot be modified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer to modify </td></tr>
    <tr><td class="paramname">bytes</td><td>pointer to bytes to copy into 'buffer' </td></tr>
    <tr><td class="paramname">start</td><td>the position to start overwriting the bytes held by buffer with 'bytes'. Must be within the bounds 0 to source-&gt;length - 1 </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes from 'bytes' to copy into the bytes held by 'buffer'. start + len must be less than source-&gt;length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the modification succeeds. false if start is out of range, or start + len is greater than source-&gt;length </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
