\hypertarget{group__openssl__crypto}{}\doxysection{Open\+SSL Crypto Engine}
\label{group__openssl__crypto}\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_gadfe740d19f9f2096b818553e90dae0d7}{openssl\+\_\+crypto\+\_\+random}} (size\+\_\+t len)
\item 
\mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_ga9177055e488f0163d3eb946799df5a67}{openssl\+\_\+cipher\+\_\+key\+\_\+random}} (\mbox{\hyperlink{structwickr__cipher}{wickr\+\_\+cipher\+\_\+t}} cipher)
\item 
\mbox{\hyperlink{structwickr__cipher__result}{wickr\+\_\+cipher\+\_\+result\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_gaf51493d43d3572265abba27e2b3fbc54}{openssl\+\_\+aes256\+\_\+encrypt}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$plaintext, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$aad, const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$key, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$iv)
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_ga75eaf118b28fb76e75579d0a74517b18}{openssl\+\_\+aes256\+\_\+decrypt}} (const \mbox{\hyperlink{structwickr__cipher__result}{wickr\+\_\+cipher\+\_\+result\+\_\+t}} $\ast$cipher\+\_\+result, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$aad, const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$key, bool only\+\_\+auth\+\_\+ciphers)
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_ga19991a9b00d0c383c64935fa2acecda7}{openssl\+\_\+sha2}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$buffer, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$salt, \mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}} mode)
\item 
\mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_ga75a01a740d558bfcc0f10920266cd9d5}{openssl\+\_\+ec\+\_\+rand\+\_\+key}} (\mbox{\hyperlink{structwickr__ec__curve}{wickr\+\_\+ec\+\_\+curve\+\_\+t}} curve)
\item 
\mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_gab2cc137ada900eba89796857603cd8cd}{openssl\+\_\+ec\+\_\+key\+\_\+import}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$buffer, bool is\+\_\+private)
\item 
\mbox{\hyperlink{structwickr__ecdsa__result}{wickr\+\_\+ecdsa\+\_\+result\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_gab32cef5c789ee1992afae98a81b65823}{openssl\+\_\+ec\+\_\+sign}} (const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$ec\+\_\+signing\+\_\+key, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$data\+\_\+to\+\_\+sign, \mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}} digest\+\_\+mode)
\item 
bool \mbox{\hyperlink{group__openssl__crypto_ga1e2b3f17c67e97360b616d0d673767f7}{openssl\+\_\+ec\+\_\+verify}} (const \mbox{\hyperlink{structwickr__ecdsa__result}{wickr\+\_\+ecdsa\+\_\+result\+\_\+t}} $\ast$signature, const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$ec\+\_\+public\+\_\+key, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$data\+\_\+to\+\_\+verify)
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_gac18a3e234621caaabf695715fb22d950}{openssl\+\_\+gen\+\_\+shared\+\_\+secret}} (const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$local, const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$peer)
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_gaeb4574976214a17eb79bbc3d76f573a6}{openssl\+\_\+hmac\+\_\+create}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$data, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$hmac\+\_\+key, \mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}} mode)
\item 
bool \mbox{\hyperlink{group__openssl__crypto_gafbde176ef6f2b99ff9dab58ad69a9a74}{openssl\+\_\+hmac\+\_\+verify}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$data, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$hmac\+\_\+key, \mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}} mode, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$expected)
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_ga788a03002d8c6048401cf0bbc2d48c7a}{openssl\+\_\+hkdf}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$input\+\_\+key\+\_\+material, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$salt, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$info, \mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}} hash\+\_\+mode)
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__openssl__crypto_ga12da75115315fbf7394f4791a2eb815c}{openssl\+\_\+sha2\+\_\+file}} (FILE $\ast$in\+\_\+file, \mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}} mode)
\item 
bool \mbox{\hyperlink{group__openssl__crypto_ga178fa1f33ad2767c27411c3ebcdd3ca0}{openssl\+\_\+encrypt\+\_\+file}} (FILE $\ast$in\+\_\+file, const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$key, FILE $\ast$out\+\_\+file)
\item 
bool \mbox{\hyperlink{group__openssl__crypto_gaf1faa509e06c188acfbdf43e2197c61a}{openssl\+\_\+decrypt\+\_\+file}} (FILE $\ast$in\+\_\+file, const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$key, FILE $\ast$out\+\_\+file, bool only\+\_\+auth\+\_\+ciphers)
\item 
bool \mbox{\hyperlink{group__openssl__crypto_ga04773a29991559a4004c23cc4e8badd7}{openssl\+\_\+enable\+\_\+fips\+\_\+mode}} (void)
\item 
bool \mbox{\hyperlink{group__openssl__crypto_gaed92eb2b892df254af6099cd472b027a}{openssl\+\_\+is\+\_\+fips\+\_\+supported}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__openssl__crypto_ga75eaf118b28fb76e75579d0a74517b18}\label{group__openssl__crypto_ga75eaf118b28fb76e75579d0a74517b18}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_aes256\_decrypt@{openssl\_aes256\_decrypt}}
\index{openssl\_aes256\_decrypt@{openssl\_aes256\_decrypt}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_aes256\_decrypt()}{openssl\_aes256\_decrypt()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+aes256\+\_\+decrypt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__cipher__result}{wickr\+\_\+cipher\+\_\+result\+\_\+t}} $\ast$}]{cipher\+\_\+result,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{aad,  }\item[{const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$}]{key,  }\item[{bool}]{only\+\_\+auth\+\_\+ciphers }\end{DoxyParamCaption})}

Decrypt a cipher\+\_\+result using AES256 Currently supports AES256-\/\+GCM and AES256-\/\+CTR cipher modes


\begin{DoxyParams}{Parameters}
{\em cipher\+\_\+result} & a cipher result generated from \textquotesingle{}openssl\+\_\+aes256\+\_\+encrypt\textquotesingle{} \\
\hline
{\em aad} & additional data to authenticate with the ciphertext (only works with authenticated ciphers) \\
\hline
{\em key} & the key to use to attempt to decrypt \textquotesingle{}cipher\+\_\+result\textquotesingle{} \\
\hline
{\em only\+\_\+auth\+\_\+ciphers} & if true, only authenticated ciphers may be used for decryption \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing decrypted bytes. If the AES mode is authenticated, NULL will be returned if key is incorrect. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gaf51493d43d3572265abba27e2b3fbc54}\label{group__openssl__crypto_gaf51493d43d3572265abba27e2b3fbc54}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_aes256\_encrypt@{openssl\_aes256\_encrypt}}
\index{openssl\_aes256\_encrypt@{openssl\_aes256\_encrypt}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_aes256\_encrypt()}{openssl\_aes256\_encrypt()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__cipher__result}{wickr\+\_\+cipher\+\_\+result\+\_\+t}}$\ast$ openssl\+\_\+aes256\+\_\+encrypt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{plaintext,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{aad,  }\item[{const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$}]{key,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{iv }\end{DoxyParamCaption})}

Encrypt a buffer using AES256 Currently supports AES256-\/\+GCM and AES256-\/\+CTR cipher modes

NOTE\+: IV is randomly chosen using \textquotesingle{}openssl\+\_\+crypto\+\_\+random\textquotesingle{} if one is not provided


\begin{DoxyParams}{Parameters}
{\em plaintext} & the content to encrypt using \textquotesingle{}key\textquotesingle{} \\
\hline
{\em aad} & additional data to authenticate with the ciphertext (only works with authenticated ciphers) \\
\hline
{\em key} & the cipher key to use to encrypt \textquotesingle{}plaintext\textquotesingle{} \\
\hline
{\em iv} & an initialization vector to use with the cipher mode, or NULL if one should be chosen at random \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a cipher result containing encrypted bytes, or NULL if the cipher mode fails or is not supported 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga9177055e488f0163d3eb946799df5a67}\label{group__openssl__crypto_ga9177055e488f0163d3eb946799df5a67}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_cipher\_key\_random@{openssl\_cipher\_key\_random}}
\index{openssl\_cipher\_key\_random@{openssl\_cipher\_key\_random}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_cipher\_key\_random()}{openssl\_cipher\_key\_random()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}}$\ast$ openssl\+\_\+cipher\+\_\+key\+\_\+random (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structwickr__cipher}{wickr\+\_\+cipher\+\_\+t}}}]{cipher }\end{DoxyParamCaption})}

Generate a secure random cipher key for a particular cipher Currently supports AES256-\/\+GCM and AES256-\/\+CTR cipher modes


\begin{DoxyParams}{Parameters}
{\em cipher} & the cipher to generate a random key for \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a cipher key containing key material generated by \textquotesingle{}openssl\+\_\+crypto\+\_\+random\textquotesingle{} or NULL if random byte generation fails 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gadfe740d19f9f2096b818553e90dae0d7}\label{group__openssl__crypto_gadfe740d19f9f2096b818553e90dae0d7}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_crypto\_random@{openssl\_crypto\_random}}
\index{openssl\_crypto\_random@{openssl\_crypto\_random}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_crypto\_random()}{openssl\_crypto\_random()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+crypto\+\_\+random (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

Generate secure random bytes using the rand\+\_\+bytes function from Open\+SSL


\begin{DoxyParams}{Parameters}
{\em len} & the number of bytes to generate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing \textquotesingle{}len\textquotesingle{} secure random bytes or NULL if random byte generation fails 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gaf1faa509e06c188acfbdf43e2197c61a}\label{group__openssl__crypto_gaf1faa509e06c188acfbdf43e2197c61a}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_decrypt\_file@{openssl\_decrypt\_file}}
\index{openssl\_decrypt\_file@{openssl\_decrypt\_file}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_decrypt\_file()}{openssl\_decrypt\_file()}}
{\footnotesize\ttfamily bool openssl\+\_\+decrypt\+\_\+file (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{in\+\_\+file,  }\item[{const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$}]{key,  }\item[{FILE $\ast$}]{out\+\_\+file,  }\item[{bool}]{only\+\_\+auth\+\_\+ciphers }\end{DoxyParamCaption})}

Decrypt a file with AES256

Note\+: Unauthenticated modes will always succeed and the contents of \textquotesingle{}out\+\_\+file\textquotesingle{} may be incorrect For this reason it is useful to use an authenticated mode such as AES256 GCM when encrypting files


\begin{DoxyParams}{Parameters}
{\em in\+\_\+file} & the encrypted file to decrypt \\
\hline
{\em key} & the key to use for decryption \\
\hline
{\em out\+\_\+file} & the file to write the decrypted data from \textquotesingle{}in\+\_\+file\textquotesingle{} \\
\hline
{\em only\+\_\+auth\+\_\+ciphers} & if true, only authenticated ciphers may be used for decryption \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the decryption operation succeeds, and \textquotesingle{}out\+\_\+file\textquotesingle{} can be written 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gab2cc137ada900eba89796857603cd8cd}\label{group__openssl__crypto_gab2cc137ada900eba89796857603cd8cd}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_ec\_key\_import@{openssl\_ec\_key\_import}}
\index{openssl\_ec\_key\_import@{openssl\_ec\_key\_import}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_ec\_key\_import()}{openssl\_ec\_key\_import()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}}$\ast$ openssl\+\_\+ec\+\_\+key\+\_\+import (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{buffer,  }\item[{bool}]{is\+\_\+private }\end{DoxyParamCaption})}

Import an Elliptic Curve key from a buffer


\begin{DoxyParams}{Parameters}
{\em buffer} & the buffer representing Elliptic Curve key material \\
\hline
{\em is\+\_\+private} & false if the buffer represents a public key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an Elliptic Curve key pair parsed from buffer or NULL if buffer does not contain a valid key, or is\+\_\+private is incorrectly set 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga75a01a740d558bfcc0f10920266cd9d5}\label{group__openssl__crypto_ga75a01a740d558bfcc0f10920266cd9d5}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_ec\_rand\_key@{openssl\_ec\_rand\_key}}
\index{openssl\_ec\_rand\_key@{openssl\_ec\_rand\_key}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_ec\_rand\_key()}{openssl\_ec\_rand\_key()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}}$\ast$ openssl\+\_\+ec\+\_\+rand\+\_\+key (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structwickr__ec__curve}{wickr\+\_\+ec\+\_\+curve\+\_\+t}}}]{curve }\end{DoxyParamCaption})}

Generate a random Elliptic Curve keypair Supported curve is currently limited to NIST P521


\begin{DoxyParams}{Parameters}
{\em curve} & the curve parameters to use for random key pair generation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a random Elliptic Curve key pair or NULL if the random generation fails 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gab32cef5c789ee1992afae98a81b65823}\label{group__openssl__crypto_gab32cef5c789ee1992afae98a81b65823}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_ec\_sign@{openssl\_ec\_sign}}
\index{openssl\_ec\_sign@{openssl\_ec\_sign}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_ec\_sign()}{openssl\_ec\_sign()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__ecdsa__result}{wickr\+\_\+ecdsa\+\_\+result\+\_\+t}}$\ast$ openssl\+\_\+ec\+\_\+sign (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$}]{ec\+\_\+signing\+\_\+key,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{data\+\_\+to\+\_\+sign,  }\item[{\mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}}}]{digest\+\_\+mode }\end{DoxyParamCaption})}

Sign data using an Elliptic Curve key Data is hashed before signing. This function will calculate ECDSA(\+SHA2(data\+\_\+to\+\_\+sign))


\begin{DoxyParams}{Parameters}
{\em ec\+\_\+signing\+\_\+key} & private signing key to use for the ECDSA algorithm \\
\hline
{\em data\+\_\+to\+\_\+sign} & the data to hash with \textquotesingle{}digest\+\_\+mode\textquotesingle{}, and then sign with \textquotesingle{}ec\+\_\+signing\+\_\+key\textquotesingle{} \\
\hline
{\em digest\+\_\+mode} & the digest mode to use for SHA2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an ecdsa result containing the output of ECDSA(\+SHA2(data\+\_\+to\+\_\+sign)) or NULL if the \textquotesingle{}ec\+\_\+signing\+\_\+key\textquotesingle{} is not a private key 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga1e2b3f17c67e97360b616d0d673767f7}\label{group__openssl__crypto_ga1e2b3f17c67e97360b616d0d673767f7}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_ec\_verify@{openssl\_ec\_verify}}
\index{openssl\_ec\_verify@{openssl\_ec\_verify}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_ec\_verify()}{openssl\_ec\_verify()}}
{\footnotesize\ttfamily bool openssl\+\_\+ec\+\_\+verify (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__ecdsa__result}{wickr\+\_\+ecdsa\+\_\+result\+\_\+t}} $\ast$}]{signature,  }\item[{const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$}]{ec\+\_\+public\+\_\+key,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{data\+\_\+to\+\_\+verify }\end{DoxyParamCaption})}

Verify ECDSA signatures


\begin{DoxyParams}{Parameters}
{\em signature} & a signature produced with \textquotesingle{}openssl\+\_\+ec\+\_\+sign\textquotesingle{} \\
\hline
{\em ec\+\_\+public\+\_\+key} & the public signing key to use for verification \\
\hline
{\em data\+\_\+to\+\_\+verify} & the original data that should have been signed with \textquotesingle{}ec\+\_\+public\+\_\+key\textquotesingle{}. It will be hashed inside this function as part of the verification process \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if \textquotesingle{}signature\textquotesingle{} can be verified by \textquotesingle{}ec\+\_\+public\+\_\+key\textquotesingle{} 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga04773a29991559a4004c23cc4e8badd7}\label{group__openssl__crypto_ga04773a29991559a4004c23cc4e8badd7}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_enable\_fips\_mode@{openssl\_enable\_fips\_mode}}
\index{openssl\_enable\_fips\_mode@{openssl\_enable\_fips\_mode}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_enable\_fips\_mode()}{openssl\_enable\_fips\_mode()}}
{\footnotesize\ttfamily bool openssl\+\_\+enable\+\_\+fips\+\_\+mode (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Enable FIPS mode

\begin{DoxyReturn}{Returns}
true if openssl fips enable is allowed 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga178fa1f33ad2767c27411c3ebcdd3ca0}\label{group__openssl__crypto_ga178fa1f33ad2767c27411c3ebcdd3ca0}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_encrypt\_file@{openssl\_encrypt\_file}}
\index{openssl\_encrypt\_file@{openssl\_encrypt\_file}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_encrypt\_file()}{openssl\_encrypt\_file()}}
{\footnotesize\ttfamily bool openssl\+\_\+encrypt\+\_\+file (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{in\+\_\+file,  }\item[{const \mbox{\hyperlink{structwickr__cipher__key}{wickr\+\_\+cipher\+\_\+key\+\_\+t}} $\ast$}]{key,  }\item[{FILE $\ast$}]{out\+\_\+file }\end{DoxyParamCaption})}

Encrypt a file with AES256


\begin{DoxyParams}{Parameters}
{\em in\+\_\+file} & the file to encrypt \\
\hline
{\em key} & the key to use for AES256 \\
\hline
{\em out\+\_\+file} & a file that should contain the encrypted data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if encryption succeeds, and \textquotesingle{}out\+\_\+file\textquotesingle{} can be written 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gac18a3e234621caaabf695715fb22d950}\label{group__openssl__crypto_gac18a3e234621caaabf695715fb22d950}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_gen\_shared\_secret@{openssl\_gen\_shared\_secret}}
\index{openssl\_gen\_shared\_secret@{openssl\_gen\_shared\_secret}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_gen\_shared\_secret()}{openssl\_gen\_shared\_secret()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+gen\+\_\+shared\+\_\+secret (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$}]{local,  }\item[{const \mbox{\hyperlink{structwickr__ec__key}{wickr\+\_\+ec\+\_\+key\+\_\+t}} $\ast$}]{peer }\end{DoxyParamCaption})}

Generate a shared secret given Elliptic Curve Diffie-\/\+Hellman parameters


\begin{DoxyParams}{Parameters}
{\em local} & the local elliptic curve private key \\
\hline
{\em peer} & the remote elliptic curve public key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing the shared secret computed with \textquotesingle{}local\textquotesingle{} private key and \textquotesingle{}peer\textquotesingle{} public key 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga788a03002d8c6048401cf0bbc2d48c7a}\label{group__openssl__crypto_ga788a03002d8c6048401cf0bbc2d48c7a}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_hkdf@{openssl\_hkdf}}
\index{openssl\_hkdf@{openssl\_hkdf}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_hkdf()}{openssl\_hkdf()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+hkdf (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{input\+\_\+key\+\_\+material,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{salt,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{info,  }\item[{\mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}}}]{hash\+\_\+mode }\end{DoxyParamCaption})}

Derive a key with HMAC Key Derivation Function


\begin{DoxyParams}{Parameters}
{\em input\+\_\+key\+\_\+material} & the original key to extract and expand using HKDF \\
\hline
{\em salt} & a salt value to provide to HKDF, this should be randomly generated or NULL if no salt should be used \\
\hline
{\em info} & contextual information to pass to HKDF, this can be NULL if no contextual information should be used \\
\hline
{\em hash\+\_\+mode} & the hash mode to use for the HKDF output, this will determine the length of the final output \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing the calculated HKDF value 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gaeb4574976214a17eb79bbc3d76f573a6}\label{group__openssl__crypto_gaeb4574976214a17eb79bbc3d76f573a6}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_hmac\_create@{openssl\_hmac\_create}}
\index{openssl\_hmac\_create@{openssl\_hmac\_create}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_hmac\_create()}{openssl\_hmac\_create()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+hmac\+\_\+create (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{data,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{hmac\+\_\+key,  }\item[{\mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}}}]{mode }\end{DoxyParamCaption})}

Generate an HMAC


\begin{DoxyParams}{Parameters}
{\em data} & the data to take the HMAC of \\
\hline
{\em hmac\+\_\+key} & a key to use for HMAC \\
\hline
{\em mode} & the digest mode to perform HMAC with. This will determine the length of the output \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing the HMAC of \textquotesingle{}data\textquotesingle{} with \textquotesingle{}hmac\+\_\+key\textquotesingle{} 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gafbde176ef6f2b99ff9dab58ad69a9a74}\label{group__openssl__crypto_gafbde176ef6f2b99ff9dab58ad69a9a74}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_hmac\_verify@{openssl\_hmac\_verify}}
\index{openssl\_hmac\_verify@{openssl\_hmac\_verify}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_hmac\_verify()}{openssl\_hmac\_verify()}}
{\footnotesize\ttfamily bool openssl\+\_\+hmac\+\_\+verify (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{data,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{hmac\+\_\+key,  }\item[{\mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}}}]{mode,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{expected }\end{DoxyParamCaption})}

Verify an HMAC against an expected result


\begin{DoxyParams}{Parameters}
{\em data} & the data to calculate the expected HMAC with \\
\hline
{\em hmac\+\_\+key} & the key to use along with \textquotesingle{}data\textquotesingle{} to create the expected HMAC with \\
\hline
{\em mode} & the mode to use for generating the expected HMAC \\
\hline
{\em expected} & the value to compare the generated HMAC with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if \textquotesingle{}expected\textquotesingle{} is equal to the HMAC of \textquotesingle{}data\textquotesingle{} and \textquotesingle{}hmac\+\_\+key\textquotesingle{} 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_gaed92eb2b892df254af6099cd472b027a}\label{group__openssl__crypto_gaed92eb2b892df254af6099cd472b027a}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_is\_fips\_supported@{openssl\_is\_fips\_supported}}
\index{openssl\_is\_fips\_supported@{openssl\_is\_fips\_supported}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_is\_fips\_supported()}{openssl\_is\_fips\_supported()}}
{\footnotesize\ttfamily bool openssl\+\_\+is\+\_\+fips\+\_\+supported (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Determine if FIPS mode is available

\begin{DoxyReturn}{Returns}
true if openssl fips mode is available 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga19991a9b00d0c383c64935fa2acecda7}\label{group__openssl__crypto_ga19991a9b00d0c383c64935fa2acecda7}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_sha2@{openssl\_sha2}}
\index{openssl\_sha2@{openssl\_sha2}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_sha2()}{openssl\_sha2()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+sha2 (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{buffer,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{salt,  }\item[{\mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}}}]{mode }\end{DoxyParamCaption})}

Calculate a SHA2 hash of a buffer using an optional salt value Supported modes of SHA2 are SHA256, SHA384 and SHA512


\begin{DoxyParams}{Parameters}
{\em buffer} & the buffer to hash \\
\hline
{\em salt} & a salt value to concatenate to buffer before taking the hash. The input to the SHA2 function will be SHA2(buffer $\vert$$\vert$ salt) Passing NULL will allow for no salt to be used \\
\hline
{\em mode} & the mode of SHA2 to use for hashing \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing the derived hash or NULL if the hashing operation fails 
\end{DoxyReturn}
\mbox{\Hypertarget{group__openssl__crypto_ga12da75115315fbf7394f4791a2eb815c}\label{group__openssl__crypto_ga12da75115315fbf7394f4791a2eb815c}} 
\index{OpenSSL Crypto Engine@{OpenSSL Crypto Engine}!openssl\_sha2\_file@{openssl\_sha2\_file}}
\index{openssl\_sha2\_file@{openssl\_sha2\_file}!OpenSSL Crypto Engine@{OpenSSL Crypto Engine}}
\doxysubsubsection{\texorpdfstring{openssl\_sha2\_file()}{openssl\_sha2\_file()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ openssl\+\_\+sha2\+\_\+file (\begin{DoxyParamCaption}\item[{FILE $\ast$}]{in\+\_\+file,  }\item[{\mbox{\hyperlink{structwickr__digest}{wickr\+\_\+digest\+\_\+t}}}]{mode }\end{DoxyParamCaption})}

Calculate the SHA2 hash of a file


\begin{DoxyParams}{Parameters}
{\em in\+\_\+file} & a file to take the hash of it\textquotesingle{}s contents \\
\hline
{\em mode} & the mode to use for calculating the hash \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer containing the output of the chosen SHA2 mode of the contents of in\+\_\+file 
\end{DoxyReturn}
