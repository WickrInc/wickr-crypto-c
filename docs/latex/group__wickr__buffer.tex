\hypertarget{group__wickr__buffer}{}\section{wickr\+\_\+buffer\+\_\+t}
\label{group__wickr__buffer}\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer}}
\begin{DoxyCompactList}\small\item\em Represents an array of bytes and the length of the allocation associated with those bytes. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{group__wickr__buffer_ga0cf6db371b58617c9311f2a357d98164}{B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN}}(x)~(sizeof(x) / sizeof(\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$))
\begin{DoxyCompactList}\small\item\em Determine the number of elements in an array of buffers (wickr\+\_\+buffer\+\_\+t $\ast$$\ast$). \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_ga305edd191e38eb040710b631c1e4f05f}{wickr\+\_\+buffer\+\_\+create\+\_\+empty}} (size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Creates an empty buffer of size length. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_gaba0ae148a2f75e50eb3d36a4bef509d2}{wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero}} (size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Creates an zeroed empty buffer of size length. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_gacc3ad1220af28781bf678cab20e2f1c8}{wickr\+\_\+buffer\+\_\+create}} (const uint8\+\_\+t $\ast$bytes, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Creates a buffer by copying an existing pointer to bytes of a specified length len. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_gada179dda91e748d7bdf6028d3d4c4bcd}{wickr\+\_\+buffer\+\_\+copy}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$source)
\begin{DoxyCompactList}\small\item\em Copy a buffer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_gaceb6345c35ac2f6330ea0a685ce3fc53}{wickr\+\_\+buffer\+\_\+copy\+\_\+section}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$source, size\+\_\+t start, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Create a buffer using a subsection of another buffer. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__wickr__buffer_ga67f817bf762e4ee401b31685197620be}{wickr\+\_\+buffer\+\_\+modify\+\_\+section}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$buffer, const uint8\+\_\+t $\ast$bytes, size\+\_\+t start, size\+\_\+t len)
\begin{DoxyCompactList}\small\item\em Modify a subsection of a buffer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_gad7721c1033a1fc378a0a11613f3cfb26}{wickr\+\_\+buffer\+\_\+concat}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$buffer1, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$buffer2)
\begin{DoxyCompactList}\small\item\em Concatenate two buffers into one new buffer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$ \mbox{\hyperlink{group__wickr__buffer_ga3aa7ea751a65310184d6c0ea9627dca8}{wickr\+\_\+buffer\+\_\+concat\+\_\+multi}} (\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$$\ast$buffers, uint8\+\_\+t n\+\_\+buffers)
\begin{DoxyCompactList}\small\item\em Concatenate n buffers. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__wickr__buffer_ga51ec58848ab0b07d164c6f7d73200c24}{wickr\+\_\+buffer\+\_\+is\+\_\+equal}} (const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$b1, const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$b2, wickr\+\_\+buffer\+\_\+compare\+\_\+func compare\+\_\+func)
\begin{DoxyCompactList}\small\item\em Compare buffers for equality. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__wickr__buffer_ga7ec1198db0739f3034ddd3969c64257f}{wickr\+\_\+buffer\+\_\+destroy}} (\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$$\ast$buffer)
\begin{DoxyCompactList}\small\item\em Destroy a buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__wickr__buffer_gaf0ff6486debbfd676b7675f6f899fc40}{wickr\+\_\+buffer\+\_\+destroy\+\_\+zero}} (\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$$\ast$buffer)
\begin{DoxyCompactList}\small\item\em Zero-\/then-\/deallocate a buffer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Macro Definition Documentation}
\mbox{\Hypertarget{group__wickr__buffer_ga0cf6db371b58617c9311f2a357d98164}\label{group__wickr__buffer_ga0cf6db371b58617c9311f2a357d98164}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN@{B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN}}
\index{B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN@{B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN}{BUFFER\_ARRAY\_LEN}}
{\footnotesize\ttfamily \#define B\+U\+F\+F\+E\+R\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+L\+EN(\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})~(sizeof(x) / sizeof(\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$))}



Determine the number of elements in an array of buffers (wickr\+\_\+buffer\+\_\+t $\ast$$\ast$). 

N\+O\+TE\+: This function will only work on stack allocated arrays. It is meant only to be used in cases where the length of the array of buffers is determined at compile time, on the stack.

E\+X\+A\+M\+P\+LE\+: wickr\+\_\+buffer\+\_\+t $\ast$elements\mbox{[}\mbox{]} = \{ b1, b2 b3 \}.


\begin{DoxyParams}{Parameters}
{\em x} & pointer to an array of wickr\+\_\+buffer\+\_\+t elements \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of elements in the array pointed to by x 
\end{DoxyReturn}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__wickr__buffer_gad7721c1033a1fc378a0a11613f3cfb26}\label{group__wickr__buffer_gad7721c1033a1fc378a0a11613f3cfb26}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+concat@{wickr\+\_\+buffer\+\_\+concat}}
\index{wickr\+\_\+buffer\+\_\+concat@{wickr\+\_\+buffer\+\_\+concat}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+concat()}{wickr\_buffer\_concat()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+concat (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{buffer1,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{buffer2 }\end{DoxyParamCaption})}



Concatenate two buffers into one new buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer1} & first source buffer \\
\hline
{\em buffer2} & second source buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer containing copied bytes from \textquotesingle{}buffer1\textquotesingle{} followed by copied bytes from \textquotesingle{}buffer2\textquotesingle{}. N\+U\+LL if the length of \textquotesingle{}buffer1\textquotesingle{} combind with the length of \textquotesingle{}buffer2\textquotesingle{} exceeds M\+A\+X\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_ga3aa7ea751a65310184d6c0ea9627dca8}\label{group__wickr__buffer_ga3aa7ea751a65310184d6c0ea9627dca8}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+concat\+\_\+multi@{wickr\+\_\+buffer\+\_\+concat\+\_\+multi}}
\index{wickr\+\_\+buffer\+\_\+concat\+\_\+multi@{wickr\+\_\+buffer\+\_\+concat\+\_\+multi}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+concat\+\_\+multi()}{wickr\_buffer\_concat\_multi()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+concat\+\_\+multi (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$$\ast$}]{buffers,  }\item[{uint8\+\_\+t}]{n\+\_\+buffers }\end{DoxyParamCaption})}



Concatenate n buffers. 


\begin{DoxyParams}{Parameters}
{\em buffers} & a pointer to an array of buffers of n length \\
\hline
{\em n\+\_\+buffers} & the number of buffers in the array pointed to by buffers \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer containing copied bytes from each buffer in \textquotesingle{}buffers\textquotesingle{}. N\+U\+LL if \textquotesingle{}buffers\textquotesingle{} contains a N\+U\+LL or the total number of bytes held by \textquotesingle{}buffers\textquotesingle{} exceeds M\+A\+X\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_gada179dda91e748d7bdf6028d3d4c4bcd}\label{group__wickr__buffer_gada179dda91e748d7bdf6028d3d4c4bcd}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+copy@{wickr\+\_\+buffer\+\_\+copy}}
\index{wickr\+\_\+buffer\+\_\+copy@{wickr\+\_\+buffer\+\_\+copy}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+copy()}{wickr\_buffer\_copy()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+copy (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{source }\end{DoxyParamCaption})}



Copy a buffer. 


\begin{DoxyParams}{Parameters}
{\em source} & the buffer to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer containing a copy of the bytes held in source. The new buffer maintains ownership of the copied bytes 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_gaceb6345c35ac2f6330ea0a685ce3fc53}\label{group__wickr__buffer_gaceb6345c35ac2f6330ea0a685ce3fc53}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+copy\+\_\+section@{wickr\+\_\+buffer\+\_\+copy\+\_\+section}}
\index{wickr\+\_\+buffer\+\_\+copy\+\_\+section@{wickr\+\_\+buffer\+\_\+copy\+\_\+section}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+copy\+\_\+section()}{wickr\_buffer\_copy\_section()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+copy\+\_\+section (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{source,  }\item[{size\+\_\+t}]{start,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Create a buffer using a subsection of another buffer. 


\begin{DoxyParams}{Parameters}
{\em source} & the buffer to copy bytes out of \\
\hline
{\em start} & the offset to start the copy process. Must be within the bounds 0 to source-\/$>$length -\/ 1 \\
\hline
{\em len} & the number of bytes to copy out of \textquotesingle{}source\textquotesingle{}. start + len must be less than source-\/$>$length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer containing the bytes within the range of start to start + len. N\+U\+LL if start + len exceeds the length of source, or if start is out of bounds 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_gacc3ad1220af28781bf678cab20e2f1c8}\label{group__wickr__buffer_gacc3ad1220af28781bf678cab20e2f1c8}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+create@{wickr\+\_\+buffer\+\_\+create}}
\index{wickr\+\_\+buffer\+\_\+create@{wickr\+\_\+buffer\+\_\+create}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+create()}{wickr\_buffer\_create()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+create (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t $\ast$}]{bytes,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Creates a buffer by copying an existing pointer to bytes of a specified length len. 


\begin{DoxyParams}{Parameters}
{\em bytes} & a valid pointer to bytes of at least size len \\
\hline
{\em len} & the number of bytes the buffer should hold. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer holding len bytes copied from bytes. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_ga305edd191e38eb040710b631c1e4f05f}\label{group__wickr__buffer_ga305edd191e38eb040710b631c1e4f05f}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+create\+\_\+empty@{wickr\+\_\+buffer\+\_\+create\+\_\+empty}}
\index{wickr\+\_\+buffer\+\_\+create\+\_\+empty@{wickr\+\_\+buffer\+\_\+create\+\_\+empty}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+create\+\_\+empty()}{wickr\_buffer\_create\_empty()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+create\+\_\+empty (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Creates an empty buffer of size length. 

The bytes in the output are uninitialized


\begin{DoxyParams}{Parameters}
{\em len} & the number of bytes the buffer should hold. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer holding len bytes, or N\+U\+LL if allocation fails or len is 0. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_gaba0ae148a2f75e50eb3d36a4bef509d2}\label{group__wickr__buffer_gaba0ae148a2f75e50eb3d36a4bef509d2}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero@{wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero}}
\index{wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero@{wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero()}{wickr\_buffer\_create\_empty\_zero()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}}$\ast$ wickr\+\_\+buffer\+\_\+create\+\_\+empty\+\_\+zero (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Creates an zeroed empty buffer of size length. 

The bytes in the output are initialized to 0


\begin{DoxyParams}{Parameters}
{\em len} & the number of bytes the buffer should hold. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a newly allocated buffer holding len bytes, or N\+U\+LL if allocation fails or len is 0. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_ga7ec1198db0739f3034ddd3969c64257f}\label{group__wickr__buffer_ga7ec1198db0739f3034ddd3969c64257f}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+destroy@{wickr\+\_\+buffer\+\_\+destroy}}
\index{wickr\+\_\+buffer\+\_\+destroy@{wickr\+\_\+buffer\+\_\+destroy}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+destroy()}{wickr\_buffer\_destroy()}}
{\footnotesize\ttfamily void wickr\+\_\+buffer\+\_\+destroy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$$\ast$}]{buffer }\end{DoxyParamCaption})}



Destroy a buffer. 

N\+O\+TE\+: This function does not modify the contents of buffer and simply calls free to deallocate the memory held. To zero out memory before deallocation use \textquotesingle{}wickr\+\_\+buffer\+\_\+destroy\+\_\+zero\textquotesingle{}


\begin{DoxyParams}{Parameters}
{\em buffer} & the buffer to destroy \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__wickr__buffer_gaf0ff6486debbfd676b7675f6f899fc40}\label{group__wickr__buffer_gaf0ff6486debbfd676b7675f6f899fc40}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+destroy\+\_\+zero@{wickr\+\_\+buffer\+\_\+destroy\+\_\+zero}}
\index{wickr\+\_\+buffer\+\_\+destroy\+\_\+zero@{wickr\+\_\+buffer\+\_\+destroy\+\_\+zero}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+destroy\+\_\+zero()}{wickr\_buffer\_destroy\_zero()}}
{\footnotesize\ttfamily void wickr\+\_\+buffer\+\_\+destroy\+\_\+zero (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$$\ast$}]{buffer }\end{DoxyParamCaption})}



Zero-\/then-\/deallocate a buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & the buffer to zero out and then destroy \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__wickr__buffer_ga51ec58848ab0b07d164c6f7d73200c24}\label{group__wickr__buffer_ga51ec58848ab0b07d164c6f7d73200c24}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+is\+\_\+equal@{wickr\+\_\+buffer\+\_\+is\+\_\+equal}}
\index{wickr\+\_\+buffer\+\_\+is\+\_\+equal@{wickr\+\_\+buffer\+\_\+is\+\_\+equal}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+is\+\_\+equal()}{wickr\_buffer\_is\_equal()}}
{\footnotesize\ttfamily bool wickr\+\_\+buffer\+\_\+is\+\_\+equal (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{b1,  }\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{b2,  }\item[{wickr\+\_\+buffer\+\_\+compare\+\_\+func}]{compare\+\_\+func }\end{DoxyParamCaption})}



Compare buffers for equality. 


\begin{DoxyParams}{Parameters}
{\em b1} & buffer to compare to b2 \\
\hline
{\em b2} & buffer to compare to b1 \\
\hline
{\em compare\+\_\+func} & the function that will be used to compare the buffers. Passing N\+U\+LL will result in memcmp being used. Function takes input as const volatile to support constant time memory comparison implemented by many crypto libraries \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the buffers are equal in length and in content 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wickr__buffer_ga67f817bf762e4ee401b31685197620be}\label{group__wickr__buffer_ga67f817bf762e4ee401b31685197620be}} 
\index{wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}!wickr\+\_\+buffer\+\_\+modify\+\_\+section@{wickr\+\_\+buffer\+\_\+modify\+\_\+section}}
\index{wickr\+\_\+buffer\+\_\+modify\+\_\+section@{wickr\+\_\+buffer\+\_\+modify\+\_\+section}!wickr\+\_\+buffer\+\_\+t@{wickr\+\_\+buffer\+\_\+t}}
\subsubsection{\texorpdfstring{wickr\+\_\+buffer\+\_\+modify\+\_\+section()}{wickr\_buffer\_modify\_section()}}
{\footnotesize\ttfamily bool wickr\+\_\+buffer\+\_\+modify\+\_\+section (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structwickr__buffer}{wickr\+\_\+buffer\+\_\+t}} $\ast$}]{buffer,  }\item[{const uint8\+\_\+t $\ast$}]{bytes,  }\item[{size\+\_\+t}]{start,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}



Modify a subsection of a buffer. 

N\+O\+TE\+: Buffers will not grow to accomidate extra bytes. The size of a buffer is currently fixed and cannot be modified


\begin{DoxyParams}{Parameters}
{\em buffer} & buffer to modify \\
\hline
{\em bytes} & pointer to bytes to copy into \textquotesingle{}buffer\textquotesingle{} \\
\hline
{\em start} & the position to start overwriting the bytes held by buffer with \textquotesingle{}bytes\textquotesingle{}. Must be within the bounds 0 to source-\/$>$length -\/ 1 \\
\hline
{\em len} & the number of bytes from \textquotesingle{}bytes\textquotesingle{} to copy into the bytes held by \textquotesingle{}buffer\textquotesingle{}. start + len must be less than source-\/$>$length. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the modification succeeds. false if start is out of range, or start + len is greater than source-\/$>$length 
\end{DoxyReturn}
